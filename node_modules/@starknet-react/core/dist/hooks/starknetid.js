"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStarknetIdContract = exports.useAddressFromStarkName = exports.useStarkName = void 0;
const react_query_1 = require("@tanstack/react-query");
const starknet_1 = require("starknet");
const providers_1 = require("../providers");
/**
 * Hook for fetching Stark name for address.
 *
 * @remarks
 *
 * This hook fetches the stark name of the specified address.
 * It defaults to the starknet.id contract but a different contract can be targetted by specifying its contract address
 * If address does not have a stark name, it will return "stark"
 *
 * @example
 * This example shows how to get the stark name of an address using the default Starknet.id contract
 * ```tsx
 * function Component() {
 *   const { data, isLoading, isError } = useStarkName({ address })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error fetching name...</span>
 *   return <span>StarkName: {data}</span>
 * }
 * ```
 *
 *  @example
 * This example shows how to get the stark name of an address specifying a different contract address
 * ```tsx
 * function Component() {
 *   const { data, isLoading, isError } = useStarkName({ address, contract: '0x1234' })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error fetching name...</span>
 *   return <span>StarkName: {data}</span>
 * }
 * ```
 */
function useStarkName({ address, contract }) {
    const { library } = (0, providers_1.useStarknet)();
    const { data, isLoading, isSuccess, isError, error, isFetching, isStale: isIdle, isFetched, isFetchedAfterMount, isRefetching, refetch, status, } = (0, react_query_1.useQuery)({
        queryKey: ['starkName'],
        queryFn: async () => {
            const account = new starknet_1.Account(library, address, starknet_1.ec.genKeyPair());
            const namingContract = contract ?? getStarknetIdContract(library.chainId);
            const result = await account.getStarkName(namingContract);
            if (result instanceof Error)
                throw new Error(result.message);
            return result;
        },
    });
    return {
        data,
        isLoading,
        isSuccess,
        isError,
        error,
        isIdle,
        isFetching,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status,
    };
}
exports.useStarkName = useStarkName;
/**
 * Hook to get the address associated to a stark name.
 *
 * @remarks
 *
 * This hook fetches the address of the specified stark name
 * It defaults to the starknetID contract but a different contract can be targetted by specifying its address
 * If stark name does not have an associated address, it will return "0x0"
 *
 * @example
 * This example shows how to get the address associated to a stark name
 * ```tsx
 * function Component() {
 *   const { data, isLoading, isError } = useAddressFromStarkName({ name: 'vitalik.stark' })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error fetching address...</span>
 *   return <span>address: {data}</span>
 * }
 * ```
 */
function useAddressFromStarkName({ name, contract, }) {
    const { library } = (0, providers_1.useStarknet)();
    const { data, isLoading, isSuccess, isError, error, isFetching, isStale: isIdle, isFetched, isFetchedAfterMount, isRefetching, refetch, status, } = (0, react_query_1.useQuery)({
        queryKey: ['addressFromStarkName'],
        queryFn: async () => {
            const keyPair = starknet_1.ec.genKeyPair();
            const account = new starknet_1.Account(library, starknet_1.ec.getStarkKey(keyPair), keyPair);
            const namingContract = contract ?? getStarknetIdContract(library.chainId);
            const result = await account.getAddressFromStarkName(name, namingContract);
            if (result instanceof Error)
                throw new Error(result.message);
            return result;
        },
    });
    return {
        data,
        isLoading,
        isSuccess,
        isError,
        error,
        isIdle,
        isFetching,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status,
    };
}
exports.useAddressFromStarkName = useAddressFromStarkName;
function getStarknetIdContract(chainId) {
    const starknetIdMainnetContract = '0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678';
    const starknetIdTestnetContract = '0x05cf267a0af6101667013fc6bd3f6c11116a14cda9b8c4b1198520d59f900b17';
    switch (chainId) {
        case starknet_1.constants.StarknetChainId.MAINNET:
            return starknetIdMainnetContract;
        case starknet_1.constants.StarknetChainId.TESTNET:
            return starknetIdTestnetContract;
        default:
            throw new Error('Starknet.id is not yet deployed on this network');
    }
}
exports.getStarknetIdContract = getStarknetIdContract;
//# sourceMappingURL=starknetid.js.map